---
layout: post
title: "《Effective Objective-C 2.0》摘要"
date: 2016-02-24 17:19:12 +0800
comments: true
categories: iOS开发  
---  
=== 
##第四章   
###第25条：总是为第三方类的分类名称加前缀  
1. 分类机制通常用于向无源码的既有类中新增功能；这个特性极为强大，但也容易产生问题：分类中所实现的每个方法都会在runtime加载分类时直接添加在类的方法列表中，如果类中本来就有此方法，而分类又实现了一次，那么分类中的方法会覆盖原来那一份实现代码，还可能会发生多次覆盖：后加入的覆盖先加入的，多次覆盖的结果已最后一个分类为准。  
2. 想在Objective-C中实现命名空间功能，只有一个办法：就是给相关名称都加上某个共用的前缀。  
3. 如果向某个类的分类中加入方法，在应用程序中，该类的每个实例均可调用这些方法。  
 
#####要点：
* 向第三方类中添加分类时，总应该给其名称加上你专用的前缀，给其中的方法名称加上你专用的前缀。  

###第26条：勿在分类中声明属性  
1. 属性是封装数据的方式，表达的意思是:类中有数据在支持着它；属性只是定义实例变量及相关存取方法的“语法糖”；类所封装的全部数据都应该定义在主接口中，这里是唯一能够定义实例变量(也就是数据)的地方。
2. 虽然从技术上说是可以在分类中声明属性的，但要避免这种做法，因为：除了“class-continuation”分类之外，其他分类都无法向类中新增实例变量，导致无法合成实现属性所需的实例变量（例外：可以声明为@dynamic表示在运行期使用消息转发机制实现）；   
2. 分类机制只是一种手段，目标在于扩展类的功能，而非封装数据；  

#####要点：
* 把封装数据所用的全部属性都定义在主接口里；
* 在“class-continuation”分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。  

###第27条：使用“class-continuation”分类隐藏实现细节  
1. Objective-C的动态消息系统的工作方式决定了其不可能实现真正的私有方法或私有实例变量。
2. “class-continuation”分类必须定义在其所接续的那个类的实现文件里，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在类的主实现文件里；
3. 编写Objective-C++代码时，“class-continuation”分类尤为游泳，因为某些情况下，必须用C++来编码；所有应用C++代码的实现文件都必须以.mm为后缀；
4. “class-continuation”分类还有一种合理用法：将public接口中声明未“只读”的属性扩展未“可读写”，以便在类的内部设置其值，这样既能令外界无法修改对象，又能在其内部按照需要管理其数据；  
5. 若对象所遵从的协议只应视为私有，则可在“class-continuation”分类中声明。  

#####要点：
* 通过“class-continuation”分类向类中新增实例变量；
* 如果某属性在主接口中声明未“只读”，而类的内部又要用设置方法修改此属性，那么就在“class-continuation”分类中将其扩展未“可读写”；
* 把私有方法的原型声明在“class-continuation”分类里面；
* 若想使类所遵循的协议不为人所知，则可于“class-continuation”分类中声明。  

###第28条：通过协议提供匿名对象  
#####要点：
* 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某种协议的id类型(id<Protocol>，匿名对象)，协议里规定了对象所应实现的方法；
* 使用匿名对象来隐藏类型名称（或类名）；
* 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示；  
=== 
##第五章 内存管理  
###第29条：通过协议提供匿名对象  
1. Objective-C通过引用计数来管理内存。每个对象都有一个计数器，其值表明还有多少个其他对象想令此对象继续存活。对象创建好之后，其引用计数大于0.retain和release操作会分别使该计数递增及递减，当计数变为0时，对象就为系统所回收并摧毁了。




###第30条：以ARC简化引用计数  
#####要点：
* 有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去类中的许多“样板代码”；
* ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作；
* 由方法所返回的对象，其内存管理语义总是通过方法名来体现，ARC将此确定为开发者必须能遵守的守则；
* ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease;

###第31条：在dealloc方法中只释放引用并解除监听  
#####要点：  
* 在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的KVO或NSNotificationCenter等通知，不要做其他事情；
* 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法；
* 执行异步任务的方法不应该在dealloc里调用；只能在正常状态下执行的那些方法页不应在dealloc里调用，因为此时对象已处于正在回收的状态了；
* 在dealloc中也不要调用属性的存取方法，因为有人可能会覆写这些方法，并于其中做一些无法在回收阶段安全执行的操作；另外，属性可能处于KVO机制的监控之下，观察者可能会在属性值改变的时候“保留”或使用这个即将回收的对象。

###第32条：编写“异常安全代码”时留意内存管理问题  
1. 在当前的运行时系统中，C++与Objective-C的异常相互兼容：从其中一门语言里抛出的异常能用另外一门语言所编写的“异常处理程序”来捕获；
2. 在发现大量异常捕获操作时，应考虑重构代码，用第21条的NSError式错误信息传递法来取代异常。  

#####要点：  
* 捕获异常时，一定要注意将try块内所创立的对象清理干净；
* 在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志-fobjc-arc-exception后，可生成这种代码，但会导致应用程序变大，而且会降低允许效率。  

###第33条：以弱引用避免保留环  
#####要点：
* 将某些引用设为weak，可以避免出现“保留环”；
* weak引用可以自动清空，页可以不自动清空。自动清空是随着ARC而引入的新特性，由运行时系统实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。

###第34条：以“自动释放池块”降低内存峰值  
#####要点：  
* 自动释放池排布在栈中，对象受到autorelease消息后，系统将其放入最顶端的池里；
* 合理运用自动释放池，可降低应用程序的内存峰值；
* @autoreleasepool这种新式写法能创建出更为轻便的自动释放池。

###第35条：用“僵尸对象(Zombie Object)”调试内存管理问题
#####要点：  
* 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能；
* 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应式为：打印一条包含消息内容及其接收者的消息，然后终止程序。


###第36条：不要使用retainCount
1. retainCount的绝对数值一般都与开发者所应留意的事情完全无关，即便只在调试时才调用此方法，通常还是无所助益的；
2. retainCount返回的引用计数只是某个给定时间点上的值，并未考虑到系统会稍后把自动释放池清空，因此不会将后续的操作从返回值里减去。
3. retainCount可能永远不返回0，因为有时系统会优化对象的释放行为，在引用计数还是1的时候就把它回收了。

#####要点：
* 对象的retainCount看似有用，实则不然，因为任何给定时间点上的“绝对引用计数”都无法反映对象生命周期的全貌；
* 引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。


##第六章 Block与GCD  
###第37条：理解“block”这一概念    
#####要点：
* blocks时C、C++、Objective-C中的词法闭包；
* block可接受参数，也可返回值；
* block可以分配在栈或堆上，也可以时全局的。分配在栈上的块可拷贝到堆里，这样的话。就和标准的Objective-C对象一样，具备引用计数了。

###第38条：为常用的块类型创建typedef  


 







