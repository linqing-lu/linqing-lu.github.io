---
layout: post
title: "《Effective Objective-C 2.0》摘要"
date: 2016-02-24 17:19:12 +0800
comments: true
categories: 
---  

###第25条：总是为第三方类的分类名称加前缀  
1. 分类机制通常用于向无源码的既有类中新增功能；这个特性极为强大，但也容易产生问题：分类中所实现的每个方法都会在runtime加载分类时直接添加在类的方法列表中，如果类中本来就有此方法，而分类又实现了一次，那么分类中的方法会覆盖原来那一份实现代码，还可能会发生多次覆盖：后加入的覆盖先加入的，多次覆盖的结果已最后一个分类为准。  
2. 想在Objective-C中实现命名空间功能，只有一个办法：就是给相关名称都加上某个共用的前缀。  
3. 如果向某个类的分类中加入方法，在应用程序中，该类的每个实例均可调用这些方法。  
 
#####要点：
* 向第三方类中添加分类时，总应该给其名称加上你专用的前缀，给其中的方法名称加上你专用的前缀。  

###第26条：勿在分类中声明属性  
1. 属性是封装数据的方式，表达的意思是:类中有数据在支持着它；属性只是定义实例变量及相关存取方法的“语法糖”；类所封装的全部数据都应该定义在主接口中，这里是唯一能够定义实例变量(也就是数据)的地方。
2. 虽然从技术上说是可以在分类中声明属性的，但要避免这种做法，因为：除了“class-continuation”分类之外，其他分类都无法向类中新增实例变量，导致无法合成实现属性所需的实例变量（例外：可以声明为@dynamic表示在运行期使用消息转发机制实现）；   
2. 分类机制只是一种手段，目标在于扩展类的功能，而非封装数据；  

#####要点：
* 把封装数据所用的全部属性都定义在主接口里；
* 在“class-continuation”分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。  

###第27条：使用“class-continuation”分类隐藏实现细节  
1. Objective-C的动态消息系统的工作方式决定了其不可能实现真正的私有方法或私有实例变量。
2. “class-continuation”分类必须定义在其所接续的那个类的实现文件里，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在类的主实现文件里；
3. 编写Objective-C++代码时，“class-continuation”分类尤为游泳，因为某些情况下，必须用C++来编码；所有应用C++代码的实现文件都必须以.mm为后缀；
4. “class-continuation”分类还有一种合理用法：将public接口中声明未“只读”的属性扩展未“可读写”，以便在类的内部设置其值，这样既能令外界无法修改对象，又能在其内部按照需要管理其数据；  
5. 若对象所遵从的协议只应视为私有，则可在“class-continuation”分类中声明。  

#####要点：
* 通过“class-continuation”分类向类中新增实例变量；
* 如果某属性在主接口中声明未“只读”，而类的内部又要用设置方法修改此属性，那么就在“class-continuation”分类中将其扩展未“可读写”；
* 把私有方法的原型声明在“class-continuation”分类里面；
* 若想使类所遵循的协议不为人所知，则可于“class-continuation”分类中声明。  

###第27条：通过协议提供匿名对象  
#####要点：
* 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某种协议的id类型(id<Protocol>，匿名对象)，协议里规定了对象所应实现的方法；
* 使用匿名对象来隐藏类型名称（或类名）；
* 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示；  

